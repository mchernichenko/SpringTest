<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
Проект corоna написан по мотивам доклада про Spring-построитель https://youtu.be/rd6wxPzXQvo
Реализованы базовые концепции Spring, т.е. c нуля написана инфраструктура спринга.
Позволяет понять как устроен Spring и как он на самом деле создаёт и настраивает запрашиваемый объект.
Реализована фабрика, то как она реализована в Spring`е, реализован контекст, с помощью которого объекты кешируются и за которым скрываются все нюансы связанные с контекстом
реализована работа с конфигураторами, с помощью которых объекты настраиваются.
Даёт понимание инверсии контроля и что такое внедрение зависимости (Inversion of Control, Dependency Injection)

Проект qouters написан по мотивам доклада про Spring-потрошитель https://www.youtube.com/watch?v=BmBr5diz8WA&t=1115s&ab_channel=JUG.ru
Здесь уже про использование Spring`а и как он устроен. После 'corоna' почти всё становится понятно зачем и почему так реализовано.

1. Создание класса и какого-нибудь метода (TerminatorQuoter)
2. Создание контекста и прописывание в него нашего класса TerminatorQuoter

3. Поднятие контекста с помощью ClassPathXmlApplicationContext. Представляет из себя

-- BeanFactoryPostProcessor (BFPP) - работают ещё до того как бинисозданы фабрикой и могут управлять тем что попадёт в BeanDefinitions
   3.1 чтение и парсинг xml, за который отвечает xmlBeanDefenitionReader и складирование всех деклараций в мапу BeanDefinitions (idBean, Декларация)
       Под декларациией понимается: класс, из которого его нужно создавать, есть ли у бина initMethed и как он называется ,какое у него проперти и пр.
       Что в этой мапе можно посмотреть так: context.getBeanDefinitionNames() - под именем понимается ид. бинов
       Помимо нашего бина там, как правило, подключённые обработчики, с помощью которых настраивается объект
       Тут нужно понимать, что в BeanDefinitions только объявленные бины в контексте, то какие из бинов реально созданы нужно запрашивать у фабрики
       т.к. она их создаёт. Запрашивать так (нафига это может потребоваться см п.4.4):
          ConfigurableListableBeanFactory factory;
          factory.getBeanDefinition(name)

-- BeanFactory --
   3.2 создание фабрики BeanFactory - центрального игрока Spring, отвечающего за создание и храниние обектов (достать её можно через ConfigurableListableBeanFactory)
   3.3 Воздание всех Singlton`ов. В BeanFactory кешируются конфигураторы (Singltones): из BeanDefinitions вытаскивает определения BeanPostProcessor`ов
       (точнее наследников BeanPostProcessor`ов) и складирование их в лист

-- BeanPostProcessor (BPP) -- они знают про аннотации
4. Создание объекта класса из контекста и его настройка. BeanFactory начинает работать по BeanDefinitions.
   4.0 Создание объекта. Вызывается конструктор через Reflection
   4.1 1-я стадия настройки (инжектим аннотированные проперти): созданный фабрикой объект прогоняется через каждый конфигуратор - класс реализующий интерфейс BeanPostProcessor
       логика реализуется в postProcessBeforeInitialization и этот метод работает всегда с оригинальным объектом, т.е. не с проксированным
       В нашем примере, создан обработчик аннотаций @InjectRandomInt - InjectRandomIntAnnotationBeanPostProcessor, который инжектит филд рандомным значением на 1-м шаге настройки.
       Чтобы данный бин попал в BeanDefinitions (п.3) его нужно поместить в контекс, причём id ему давать смысла нет, т.к. это инфраструктурный бин
   4.2 Запуск initMethod. У бина запускается метод, помеченный аннотацией @PostConstruct. Также можно указать инитМетод в контексте.
       В контексте должен быть прописан соответствующий обработчик @PostConstruct, он стандартный - CommonAnnotationBeanPostProcessor, так что своего писать не нужно
       Можно сразу подключить nameSpace: указать (context:annotation-config/> - чтобы подключить сразу все встроенные обработчики
   4.3 2-я стадия настройки - проксирование - изменение поведения, т.е. добавление какой-то логики в существующий класс.
       Это 1-м проходом нельзя сделать, т.к. у прокси объекта уже нет никаких аннотаций, т.к. он генерится налету
       Логика в postProcessAfterInitialization и в этот метод может быть передан как оригинальный, так и прокси метод, т.к. оборачивать в прокси можно несколько раз.
       Она нужна для того чтобы иметь возможность обернуть объект в прокси.
       Например, для профилирования - замера скорости работы методов, т.е. в каждый метод бина нужно встроить дополнительную логику.
       В нашем примере создан профайлинг методов класса помеченного аннотацией @Profiling, который можно включать и отключать через JConsole
       Это сделано через MBeanServer, который запускается вместе с java-процессом, и те объекты, которые зареганы в MBeanServer можно управлять через JConsole,
       а герать в MBeanServer можно только классы реализующие интерфейс, где на конце *MBean. В этом интерфейсе прописываются методы, которые хотим, чтобы были доступны через JConsole
   4.4 3-я стадия настройки. Она может понадобиться, например, при загрузке данных из БД, но это можно сделать при уже полностью настроенном объекте
       Для этого создаётся новая аннотация @PostProxy и помеченные методы этой аннотацией будут запускаться автоматически после полной настройки объекта
       Но как отловить событие полной настройки объекта? Есть слушатель контекста - ApplicationListener, который может ловить несколько событий:
         - ContextStarterEvent - контекст начал свое построение, когда заканчивает построение он делает Refresh
         - ContextStoppedrEvent
         - ContextRefreshedEvent - событие, когда объект полностью построился, нам он нужен
         - ContextClosedEvent
       Чтобы отловить нужное событие пишем обработчик public class PostProxyInvokerContextListener implements ApplicationListener(ContextRefreshedEvent>
       и там пишем обработку @PostProxy
       В этом обработчике нам нужно реальный класс, который имплементирует бин, чтобы через Reflection произвести поиск аннотации.
       Здесь есть нюанс (см. п. 3.1), что из контекста по имени бина это не достать. В мапе контекста, напротив имени бина лежит текущая реализация, а это может быть прокси,
       где нет уже никаких аннотаций. За реальной имплементацией нужно сходить в фабрику, т.к. та мапа заполняется на шаге 4.0 (при создании объекта, а не при его настройке)
       Ходить напрямую в фабрику из спринга это нормально, иначе это очень плохо (это не правильное использование спринга, если только не в качастве костыля).
4.5 Настроенный объект кладётся в IoC-контейнер (по сути простая мапа)
5. Вызов метода объекта

Про BeanFactoryPostProcessor:
Например, в контексте прописан бин имеющий филды: логин/пароль и пароль, естественно, мы не хотим прописывать в xml, там только ${password},
а реальное значение должно взяться из другого места. Подкрутить BeanDefinitions можно как раз в BFPP.
BFPP может ещё и саму фарбрику подкрутить до того как она начнёт работать.
В нашем примере вводим новую аннотацию @DeprecatedClass, все классы помеченные ей должны заменяться на новые, при чём до создания класса фабрикой
Обработку аннотации делаем здесь public class DeprecationHandlerBeanFactoryBeanProcessor implements BeanFactoryPostProcessor
в итоге context.getBean("terminatorQuoterId").getClass() в итоге вернёт класс T1000, а не TerminatorQuoter, который приписан у контексте

@Component - аннотация, позволяющая не прописывать бин к xml. В текстовой конфигурации имеет смысл хранить те бины, реализацию которых можно подменять без перекомпиляции,
но большинство бинов не будет менять реализацию, захломлять этими бинами xml смысла нет.
для этого в контексте прописываем context:component-scan base-package="com.*"

Про ClassPathBeanDefenitionScaner - сканирует пакет и  ищет все бины аннотированные @Component. Всё что он делает - создаёт дополнительные BeanDefinitions из всех классов
аннотированные @Component или другой аннотицией аннотированной @Component

В Spring 3 появилась возможность конфигурировать бины в JavaConfig. Это даёт гибкость в том плане, что можно писать дополнительную логику,
которая выполняется при создании бина и которую в xml написать нельзя.

В Spring 4 появилcя Groovy Config

Итого имеем, что есть несколько видов контекста:
   ClassPathXmlApplicationContext - отвечает за создание контекста из xml
   AnnotationConfigApplicationContext - отвечает за создание контекста из JavaConfig
   GenericGroovyApplicationContext - отвечает за создание контекста из GroovyConfig
   FileSystemXmlApplicationContext  - отвечает за создание контекста из ???

В примере показано написание своего контекста из проверти файла


</body>
</html>